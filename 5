class Node:
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None
        self.isThreaded = False  # indicates if right pointer is a thread

# Helper function to insert nodes into a regular BST
def insert(root, key):
    if not root:
        return Node(key)
    if key < root.data:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root

# Function to convert to threaded binary tree
def create_threaded(root):
    def convert(node, prev):
        if not node:
            return prev
        # Recur on left subtree
        prev = convert(node.left, prev)

        # If previous node exists and its right is None, thread it
        if prev and not prev.right:
            prev.right = node
            prev.isThreaded = True

        # Update previous node to current
        prev = node

        # Recur on right subtree
        if not node.isThreaded:
            prev = convert(node.right, prev)

        return prev

    convert(root, None)
    return root

# Inorder traversal without recursion using threads
def inorder_threaded(root):
    curr = leftmost(root)
    while curr:
        print(curr.data, end=" ")
        if curr.isThreaded:
            curr = curr.right
        else:
            curr = leftmost(curr.right)

def leftmost(node):
    while node and node.left:
        node = node.left
    return node

# --- Example usage ---
root = None
for key in [20, 10, 30, 5, 15, 25, 35]:
    root = insert(root, key)

print("Inorder traversal before threading:")
def inorder(node):
    if node:
        inorder(node.left)
        print(node.data, end=" ")
        inorder(node.right)
inorder(root)
print()

# Convert to threaded and traverse
create_threaded(root)
print("Inorder traversal using threads:")
inorder_threaded(root)
