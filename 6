class Graph:
    def __init__(self):
        self.graph = {}
        
    # Add a flight path (edge)
    def add_edge(self, city1, city2, cost):
        if city1 not in self.graph:
            self.graph[city1] = []
        if city2 not in self.graph:
            self.graph[city2] = []
        self.graph[city1].append((city2, cost))
        self.graph[city2].append((city1, cost))  # Undirected graph
    
    # Depth-First Search (DFS) to check connectivity
    def dfs(self, city, visited):
        visited.add(city)
        for neighbor, _ in self.graph.get(city, []):
            if neighbor not in visited:
                self.dfs(neighbor, visited)
    
    # Check if the graph is connected
    def is_connected(self):
        visited = set()
        # Start DFS from any node, here we choose the first node in the graph
        start_city = list(self.graph.keys())[0]
        self.dfs(start_city, visited)
        
        # If all cities are visited, then the graph is connected
        return len(visited) == len(self.graph)

# Example usage:
g = Graph()
g.add_edge('CityA', 'CityB', 120)  # Flight between CityA and CityB with a cost of 120 (time or fuel)
g.add_edge('CityB', 'CityC', 150)
g.add_edge('CityA', 'CityC', 180)
g.add_edge('CityD', 'CityE', 200)

# Check if the graph is connected
if g.is_connected():
    print("The flight network is connected.")
else:
    print("The flight network is not connected.")
